import React, { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'
import { createBrowserRouter, RouterProvider } from "react-router-dom";
import Layout from './router/Layout.jsx';
import About from './components/about/About.jsx';
import SkillPage from './pages/SkillPage.jsx';
import BlogPage from './pages/BlogPage.jsx'
import ProjectsPage from './pages/ProjectsPage.jsx'
import Services from './components/services/Services.jsx';
import ServicesPage from './pages/ServicesPage.jsx';
import project1 from './assets/project1.png'
import project2 from './assets/project2.png'
import project3 from './assets/project3.png'
import project4 from './assets/project4.png'
import project5 from './assets/project5.png'
import blog1 from "./assets/blog1.png";
import BlogDetails from './pages/BlogDetails.jsx';
import vdom from "./assets/vdom.jpg";
import oop from "./assets/oop.jpg";
import pi from "./assets/pi.jpg";
import asyncjs from "./assets/asyncjs.jpg";
import bt from "./assets/bt.jpg";
import jsev from "./assets/jsev.jpg";
import jsblog from "./assets/jsblog.jpg";

const blogs = [
  {
    id: 1,
    date: "12 Mar 2025",
    title: "React Virtual DOM",
    link: "#",
    image: vdom,
    content: (    <p className='text-body-sm md:text-body'>
    Understanding the Power of the React Virtual DOM
<br /><br />
React, developed by Facebook, has become one of the most popular JavaScript libraries for building user interfaces, particularly single-page applications. One of the key features that contribute to React's performance and flexibility is the concept of the Virtual DOM. In this article, we will explore what the Virtual DOM is, how it works, and why it is so essential to React's performance.
<br /><br />
What is the Virtual DOM?
The Virtual DOM is an in-memory representation of the actual DOM elements generated by React components before any changes are made to the web page. It acts as an intermediary between the developer's code and the actual browser DOM. The Virtual DOM allows React to keep track of changes and update the web page more efficiently.
<br /><br />
How Does the Virtual DOM Work?
The process of updating the web page using the Virtual DOM involves three main steps:
<br /><br />
Rendering to the Virtual DOM: When a component's state or props change, React creates a new Virtual DOM tree representing the updated state of the UI.
<br /><br />
Diffing: React compares the new Virtual DOM tree with the previous one to determine what has changed. This comparison process is known as "diffing."
<br /><br />
Updating the Real DOM: React applies only the necessary changes to the actual DOM based on the differences found during the diffing process. This minimizes the number of operations needed to update the UI and results in better performance.
<br /><br />
Key Benefits of the Virtual DOM
Improved Performance: By updating only the parts of the DOM that have changed, React reduces the number of expensive DOM manipulations, leading to faster rendering times.
<br /><br />
Declarative Programming: Developers can describe what the UI should look like for a given state without worrying about how to efficiently update the DOM. React handles the updates automatically.
<br /><br />
Cross-Platform Compatibility: The Virtual DOM allows React to be used for both web and mobile development (with React Native) without significant changes to the codebase.
<br /><br />
Consistency and Predictability: The Virtual DOM ensures that the UI is consistently updated in a predictable manner, reducing the likelihood of bugs related to DOM manipulation.
    </p>)
  },
  {
    id: 2,
    date: "26 Feb 2025",
    title: "Object-Oriented Programming in JavaScript",
    link: "#",
    image: oop,
    content: (    <p className='text-body-sm md:text-body'>
    Object-Oriented Programming in JavaScript-
    <br /><br />
Object-Oriented Programming (OOP) is a powerful paradigm that has shaped modern software development. JavaScript, although initially designed as a scripting language for web browsers, has evolved to embrace OOP principles, making it versatile for both front-end and back-end development. Here's a dive into the world of OOP in JavaScript.
<br /><br />
What is Object-Oriented Programming?
OOP is a programming paradigm based on the concept of "objects," which can contain data (in the form of properties) and code (in the form of methods). The primary goal of OOP is to increase the flexibility and maintainability of code by organizing it into reusable objects.
<br /><br />
Key Concepts of OOP-
1. Classes and Objects:
Classes are blueprints for creating objects.
Objects are instances of classes, encapsulating data and behavior.
<br /><br />
2. Encapsulation:
This principle refers to bundling the data (properties) and methods (functions) that operate on the data into a single unit, or object.
Encapsulation restricts direct access to some of the object's components, which can prevent the accidental modification of data.
<br /><br />
3. Inheritance:
Inheritance allows one class to inherit the properties and methods of another class.
This promotes code reusability and a logical hierarchy.
<br /><br />
4. Polymorphism:
Polymorphism means "many forms" and allows methods to do different things based on the object it is acting upon.
It provides a way to perform a single action in different forms.
<br /><br />
<br /><br />
OOP in JavaScript-
JavaScript uses prototypes instead of classical inheritance found in other OOP languages like Java or C++. However, with the introduction of ES6 (ECMAScript 2015), JavaScript developers can now use the class syntax, making it easier to implement OOP concepts.
<br /><br />
<br /><br />
Embracing OOP in JavaScript can lead to more organized, efficient, and scalable code. Whether you're building small applications or large-scale enterprise solutions, understanding and applying OOP principles can greatly enhance your coding practice.
    </p>)
  },
  {
    id: 3,
    date: "26 Feb 2025",
    title: "Immutable Nature of Math.PI ",
    link: "#",
    image: pi,
    content: (    <p className='text-body-sm md:text-body'>
    Exploring the Immutable Nature of Math.PI in JavaScript
    <br /><br />
Ever wanted to defy the laws of math? How about changing the value of Math.PI in JavaScript? Spoiler alert: You can try, but math will always have the last word. Here's a fun dive into why some things just can't be changed.
In JavaScript, Math.PI gives us the value of Ï€ (pi), approximately 3.14159. Now, what if we could change it to something else? Let's say we want Math.PI to be 3.2, just for kicks.
<br /><br />
Math.PI = 3.2;
console.log(Math.PI); // Outputs: 3.141592653589793
<br /><br />
As expected, our attempt to change the value of Math.PI didn't work. Why? Because Math.PI is a read-only property, meaning its value is immutableâ€”once set, it cannot be changed. This ensures mathematical accuracy and integrity across programs.
<br /><br />
So why even try to change Math.PI? For one, itâ€™s a great way to understand constants in JavaScript. Constants like Math.PI are fundamental to the language, ensuring that core mathematical principles are upheld.
<br /><br />
Here's a takeaway: while innovation often means breaking the rules, some rules are there for a reason. Constants keep our code predictable and reliable. So next time you're coding, remember: some things are best left unchanged. 
<br /><br />
Even with Object.defineProperty(), the Math.PI value remains untouchable. It's safeguarded as a read-only property, keeping it constant and accurate. So even advanced JavaScript methods won't let you rewrite the essence of Ï€. Some things are just non-negotiable!
    </p>)
  },
  {
    id: 4,
    date: "25 Feb 2025",
    title: "Asynchronous JavaScriptâ€‹",
    link: "#",
    image: asyncjs,
    content: (    <p className='text-body-sm md:text-body'>
    Asynchronous JavaScript: Callback Hell, Promises, and Async/Await.
    <br /><br />
Asynchronous JavaScript is key to efficient web development. Here's a quick dive into its evolution: Callback Hell, Promises, and Async/Await.
<br /><br />
Callback Hell:
Nesting multiple callbacks, making the code hard to read.
Example:
<br /><br />
{/* firstTask(() => {
 secondTask(() => {
 thirdTask();
 });
}); */}
<br /><br />
Promises:
Provides a cleaner way to handle asynchronous operations.
Example:
<br /><br />
{/* firstTask()
 .then(secondTask)
 .then(thirdTask); */}
<br /><br />
Async/Await:
Makes asynchronous code look more like synchronous code.
Example:
<br /><br />
{/* const performTasks = async () => {
 await firstTask();
 await secondTask();
 await thirdTask();
}; */}
performTasks();
<br /><br />
Conclusion: From Callback Hell to Async/Await, JavaScript has evolved to make asynchronous code cleaner and more readable. Mastering these tools is essential for modern web development.
    </p>)
  },
  {
    id: 5,
    date: "22 Feb 2025",
    title: "Bootstrap and Tailwind CSS",
    link: "#",
    image: bt,
    content: (    <p className='text-body-sm md:text-body'>
    Bootstrap and Tailwind CSS: A New Developer's Journey.....
    <br /><br />
As a newcomer to web development, I've been exploring various tools and frameworks to enhance my skills. Recently, I've had the chance to work with both Bootstrap and Tailwind CSS. 
<br /><br />
Bootstrap is a popular front-end framework known for its ease of use and quick setup, offering pre-designed components and a responsive grid system. Its 12-column grid system ensures layout adaptability to different screen sizes and provides extensive documentation and community support. However, it has customization limitations and can increase the size of your project.
<br /><br />
Tailwind CSS is a utility-first CSS framework that allows you to build custom designs without leaving your HTML. It offers high customization, performance, consistency, and design freedom by removing unused styles with tools like PurgeCSS. Tailwind doesn't impose any design decisions, giving you full control over your UI. However, the utility-first approach can be overwhelming for beginners and can clutter your HTML with numerous utility classes.
<br /><br />
As someone new to web development, Bootstrap was a great choice for quickly prototyping projects with minimal customization. However, if you want full control over your design and are willing to invest time in learning, Tailwind CSS is worth exploring. Both Bootstrap and Tailwind CSS have their place in a developer's toolkit, but Bootstrap is a great choice for beginners and those looking to invest time in learning. Share your thoughts and experiences with these frameworks in the comments.
    </p>)
  },
  {
    id: 6,
    date: "20 Feb 2025",
    title: "JavaScrip: The Evolution of the Web",
    link: "#",
    image: jsev,
    content: (    <p className='text-body-sm md:text-body'>
    In just ten days in 1995, Brendan Eich, a young Netscape developer, created a scripting language. The web has since been completely transformed by this language, which was first known as Mocha, then changed to LiveScript, and finally JavaScript. 
JavaScript grew rapidly from its humble beginnings as a simple language for web animations and interactivity. It moved server-side with the release of Node.js in 2009, enabling programmers to use JavaScript for backend development. As frameworks and libraries like Angular, Vue.js, and React have grown in popularity, JavaScript has become one of the most widely used and adaptable programming languages worldwide. 
These days, JavaScript powers everything from straightforward webpages to intricate apps and even Internet of Things gadgets. Its user base keeps expanding, innovating, and pushing the boundaries of what's possible on the web. ðŸŒŸ
<br /><br />
ðŸ’¡ Fun fact: Did you know that over 97% of websites use JavaScript on the client side? Truly a testament to its impact and utility!
    </p>)
  },
  {
    id: 7,
    date: "18 Feb 2025",
    title: "MERN Stack",
    link: "#",
    image: jsblog,
    content: (    <p className='text-body-sm md:text-body'>
    The MERN Stack is a JavaScript-based framework that enables developers to create full-stack web applications. It comprises MongoDB, Express.js, React, and Node.js. MongoDB is a NoSQL database that stores data in flexible, JSON-like documents. Express.js is a web application framework for Node.js, providing robust features for web and mobile applications. React is a JavaScript library for building user interfaces, particularly single-page applications. Node.js is a JavaScript runtime built on Chrome's V8 JavaScript engine, enabling server-side scripting.
    <br /><br />
MERN offers full-Stack JavaScript, streamlined development on both client and server sides. Its flexible schema and component-based architecture make it easy to scale applications. Node.js's non-blocking architecture ensures high performance and scalability. The active community provides resources, tutorials, and support.
<br /><br />
Working with the MERN Stack has been a game-changer for web developers, allowing for rapid development and deployment of web applications. Key takeaways include MongoDB simplifying data storage, Express.js streamlining server-side development, React enhancing the user experience with dynamic and responsive interfaces, and Node.js powering the backend with efficient and scalable solutions.
    </p>)
  },
  {
    id: 8,
    date: "12 Feb 2025",
    title: "The Future of the Tech Industry",
    link: "#",
    image: blog1,
    content: (    <p className='text-body-sm md:text-body'>
    The tech industry is rapidly evolving, with significant developments and trends shaping the future. Machine learning and artificial intelligence are revolutionizing various industries, such as healthcare and finance, by facilitating better decision-making and automating processes.
    <br /><br />
Quantum information could resolve complex issues unsolvable by conventional computers, such as drug development, materials research, and cryptography. Beyond 5G networks, the introduction of lower latency and better speeds is expected to transform communication, leading to developments in smart cities, driverless cars, and the Internet of Things. 
<br /><br />
Decentralized technologies and blockchain are being explored for their potential in digital identity, voting systems, and supply chain management. Green technology and sustainability are being prioritized in response to the global climate crisis, with innovations in sustainable manufacturing, energy-efficient computing, and renewable energy.
<br /><br />
Virtual and augmented reality are transforming the way we engage with the digital world, while online safety is becoming more important due to our growing reliance on digital infrastructure.
<br /><br />
The tech sector has an exciting future filled with both potential and challenges, and web developers are excited to contribute to this adventure.
    </p>)
  },
];



const projects= [
  {
    img: project1,
    category: "Web Design",
    title: "Petroil-- a landing page",
    description: "petroil is a simple landing page with React and tailwind.",
    link: "https://petroil-ten.vercel.app/"
  },
  {
    img: project2,
    category: "Web Design",
    title: "Muslim Name Generator",
    description: "Over 1000+ Muslim names",
    link: "https://meheraj786.github.io/muslim-name-generator/"
  },
  {
    img: project3,
    category: "Web Design",
    title: "Finsweet",
    description: "static and multi page website",
    link: "https://meheraj786.github.io/finsweet-webpage/"
  },
  {
    img: project4,
    category: "Web Design",
    title: "A Simple Website Design with Figma",
    description: "Sed ut perspiciatis unde omnis natus totam rem aperiam eaque inventore veritatis",
    link: "https://landing-page-website-with-react.vercel.app/"
  },
  {
    img: project5,
    category: "Web Design",
    title: "Authentication with Appwrite",
    description: "Signup and Login with react and appwrite",
    link: "https://authentication-with-react.vercel.app/login"
  },
];

const router = createBrowserRouter([
  {
    path: "/",
    element: <Layout />, // common layout
    children: [
      { path: "/", element: <App projects={projects} blogs={blogs} /> },
      { path: "/skill", element: <SkillPage /> },
      { path: "/blog", element: <BlogPage blogs={blogs} /> },
      { path: "/projects", element: <ProjectsPage projects={projects}/>},
      { path: "/about", element: <About/>},
      { path: "/services", element: <ServicesPage/>},
      { path: "/blogs/:blogId", element: <BlogDetails blogs={blogs}/>},

    ],
  },
]);


createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>

)
